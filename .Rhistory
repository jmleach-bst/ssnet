)
} else {
return(model_fit)
}
}
expect_error(cv_ssnet(model = "ss",
x = matrix(rnorm(10*10), nrow = 10, ncol = 10),
y = rnorm(10),
foldid = list(f1 = sample(1:3, 10, T),
f2 = sample(1:3, 10, T))),
"foldid must be NULL or a (numeric) vector, matrix, or data frame."
)
library(ssnet)
expect_error(cv_ssnet(model = "ss",
x = matrix(rnorm(10*10), nrow = 10, ncol = 10),
y = rnorm(10),
foldid = list(f1 = sample(1:3, 10, T),
f2 = sample(1:3, 10, T))),
"foldid must be NULL or a (numeric) vector, matrix, or data frame."
)
library(testthat)
expect_error(cv_ssnet(model = "ss",
x = matrix(rnorm(10*10), nrow = 10, ncol = 10),
y = rnorm(10),
foldid = list(f1 = sample(1:3, 10, T),
f2 = sample(1:3, 10, T))),
"foldid must be NULL or a (numeric) vector, matrix, or data frame."
)
#'
#' cv_ssnet(
#'   model = "ss", family = "multinomial",
#'   x = rbind(xtr, xte), y = c(ymtr, ymte),
#'   s0 = c(0.01, 0.05, 0.10), s1 = c(1, 2.5),
#'   nfolds = 3, ncv = 2, classify = FALSE,
#'   output_param_est = TRUE
#' )
#'
#' @export
cv_ssnet <- function(
model, alpha = c(0.5, 1),
s0 = seq(0.01, 0.1, 0.01), s1 = c(1, 2.5),
classify = FALSE, classify.rule = 0.5,
nfolds = 10, ncv = 1, foldid = NULL, fold.seed = NULL,
x, y, family, offset = NULL, epsilon = 1e-04,
maxit = 50, init = NULL, group = NULL,
Warning = FALSE, verbose = FALSE, opt.algorithm = "LBFGS",
iar.data = NULL, iar.prior = FALSE,
p.bound = c(0.01, 0.99), tau.prior = "none",
stan_manual = NULL, lambda.criteria = "lambda.min",
output_param_est = FALSE
)
{
# reproducibility
if (is.null(fold.seed) == FALSE) {
set.seed(fold.seed)
}
# for storing model fitness output
model_fit <- NULL
# for storing parameter estimates
if (output_param_est == TRUE) {
param_est <- NULL
}
# ensure foldid is valid or build foldid from scratch
if (is.null(foldid) == FALSE) {
if (
is.numeric(foldid) == FALSE &
is.matrix(foldid) == FALSE &
is.data.frame(foldid) == FALSE) {
stop("ugh!")
#stop("foldid must be NULL or a (numeric) vector, matrix, or data frame.")
}
if (is.vector(foldid) == TRUE) {
ncv <- 1
nfolds <- length(unique(foldid))
foldid <- matrix(foldid, ncol = 1)
} else {
ncv <- ncol(foldid)
nfolds.b <- c()
for (nf in 1:NF) {
nfolds.b[nf] <- length(unique(foldid[ , nf]))
}
if (any(nfolds.b != nfolds.b[1])) {
stop("Each column of foldid must have the same number of unique folds.")
} else {
nfolds <- nfolds.b[1]
}
}
} else {
foldid <- matrix(
sample(1:nfolds, size = nrow(x) * ncv, replace = TRUE),
ncol = ncv,
nrow = nrow(x)
)
}
# begin cv procedure
for (i in 1:ncv) {
for (j in 1:nfolds) {
# divide data into:
# training set (all but fold j)
xtr.ij <- x[foldid[ , i] != j, ]
ytr.ij <- y[foldid[ , i] != j]
# test set (fold j)
xte.ij <- x[foldid[ , i] == j, ]
yte.ij <- y[foldid[ , i] == j]
for (a in 1:length(alpha)) {
for (s0b in 1:length(s0)) {
for (s1b in 1:length(s1)) {
mod.ijas <- validate_ssnet(
model = model, family = family,
alpha = alpha[a], s0 = s0[s0b], s1 = s1[s1b],
x.train = xtr.ij, y.train = ytr.ij,
x.test = xte.ij, y.test = yte.ij,
classify = classify, classify.rule = classify.rule,
type.multinomial = type.multinomial,
offset = offset, epsilon = epsilon,
maxit = maxit, init = init, group = group,
Warning = Warning, verbose = verbose,
opt.algorithm = opt.algorithm,
iar.data = iar.data, iar.prior = iar.prior,
p.bound = p.bound, tau.prior = tau.prior,
stan_manual = stan_manual, lambda.criteria = lambda.criteria,
output_param_est = output_param_est
)
if (output_param_est == FALSE) {
mod.fit.ijas <- cbind(
model = model,
ncv.id = i,
fold.id = j,
alpha = alpha[a],
s0 = s0[s0b],
s1 = s1[s1b],
mod.ijas
)
} else {
mod.fit.ijas <- cbind(
model = model,
ncv.id = i,
fold.id = j,
alpha = alpha[a],
s0 = s0[s0b],
s1 = s1[s1b],
mod.ijas$model_fitness
)
param.est.ijas <- cbind(
model = model,
ncv.id = i,
fold.id = j,
alpha = alpha[a],
s0 = s0[s0b],
s1 = s1[s1b],
mod.ijas$param_est
)
param_est <- dplyr::bind_rows(
param_est,
param.est.ijas
)
}
model_fit <- dplyr::bind_rows(
model_fit,
mod.fit.ijas
)
}
}
}
}
}
if (output_param_est == TRUE) {
return(
list(
model_fit = model_fit,
param_est = param_est
)
)
} else {
return(model_fit)
}
}
expect_error(cv_ssnet(model = "ss",
x = matrix(rnorm(10*10), nrow = 10, ncol = 10),
y = rnorm(10),
foldid = list(f1 = sample(1:3, 10, T),
f2 = sample(1:3, 10, T))),
"ugh!"
)
#'
#' cv_ssnet(
#'   model = "ss", family = "multinomial",
#'   x = rbind(xtr, xte), y = c(ymtr, ymte),
#'   s0 = c(0.01, 0.05, 0.10), s1 = c(1, 2.5),
#'   nfolds = 3, ncv = 2, classify = FALSE,
#'   output_param_est = TRUE
#' )
#'
#' @export
cv_ssnet <- function(
model, alpha = c(0.5, 1),
s0 = seq(0.01, 0.1, 0.01), s1 = c(1, 2.5),
classify = FALSE, classify.rule = 0.5,
nfolds = 10, ncv = 1, foldid = NULL, fold.seed = NULL,
x, y, family, offset = NULL, epsilon = 1e-04,
maxit = 50, init = NULL, group = NULL,
Warning = FALSE, verbose = FALSE, opt.algorithm = "LBFGS",
iar.data = NULL, iar.prior = FALSE,
p.bound = c(0.01, 0.99), tau.prior = "none",
stan_manual = NULL, lambda.criteria = "lambda.min",
output_param_est = FALSE
)
{
# reproducibility
if (is.null(fold.seed) == FALSE) {
set.seed(fold.seed)
}
# for storing model fitness output
model_fit <- NULL
# for storing parameter estimates
if (output_param_est == TRUE) {
param_est <- NULL
}
# ensure foldid is valid or build foldid from scratch
if (is.null(foldid) == FALSE) {
if (
is.numeric(foldid) == FALSE &
is.matrix(foldid) == FALSE &
is.data.frame(foldid) == FALSE) {
stop("foldid must be a numeric vector, matrix, or data frame.")
#stop("foldid must be NULL or a (numeric) vector, matrix, or data frame.")
}
if (is.vector(foldid) == TRUE) {
ncv <- 1
nfolds <- length(unique(foldid))
foldid <- matrix(foldid, ncol = 1)
} else {
ncv <- ncol(foldid)
nfolds.b <- c()
for (nf in 1:NF) {
nfolds.b[nf] <- length(unique(foldid[ , nf]))
}
if (any(nfolds.b != nfolds.b[1])) {
stop("Each column of foldid must have the same number of unique folds.")
} else {
nfolds <- nfolds.b[1]
}
}
} else {
foldid <- matrix(
sample(1:nfolds, size = nrow(x) * ncv, replace = TRUE),
ncol = ncv,
nrow = nrow(x)
)
}
# begin cv procedure
for (i in 1:ncv) {
for (j in 1:nfolds) {
# divide data into:
# training set (all but fold j)
xtr.ij <- x[foldid[ , i] != j, ]
ytr.ij <- y[foldid[ , i] != j]
# test set (fold j)
xte.ij <- x[foldid[ , i] == j, ]
yte.ij <- y[foldid[ , i] == j]
for (a in 1:length(alpha)) {
for (s0b in 1:length(s0)) {
for (s1b in 1:length(s1)) {
mod.ijas <- validate_ssnet(
model = model, family = family,
alpha = alpha[a], s0 = s0[s0b], s1 = s1[s1b],
x.train = xtr.ij, y.train = ytr.ij,
x.test = xte.ij, y.test = yte.ij,
classify = classify, classify.rule = classify.rule,
type.multinomial = type.multinomial,
offset = offset, epsilon = epsilon,
maxit = maxit, init = init, group = group,
Warning = Warning, verbose = verbose,
opt.algorithm = opt.algorithm,
iar.data = iar.data, iar.prior = iar.prior,
p.bound = p.bound, tau.prior = tau.prior,
stan_manual = stan_manual, lambda.criteria = lambda.criteria,
output_param_est = output_param_est
)
if (output_param_est == FALSE) {
mod.fit.ijas <- cbind(
model = model,
ncv.id = i,
fold.id = j,
alpha = alpha[a],
s0 = s0[s0b],
s1 = s1[s1b],
mod.ijas
)
} else {
mod.fit.ijas <- cbind(
model = model,
ncv.id = i,
fold.id = j,
alpha = alpha[a],
s0 = s0[s0b],
s1 = s1[s1b],
mod.ijas$model_fitness
)
param.est.ijas <- cbind(
model = model,
ncv.id = i,
fold.id = j,
alpha = alpha[a],
s0 = s0[s0b],
s1 = s1[s1b],
mod.ijas$param_est
)
param_est <- dplyr::bind_rows(
param_est,
param.est.ijas
)
}
model_fit <- dplyr::bind_rows(
model_fit,
mod.fit.ijas
)
}
}
}
}
}
if (output_param_est == TRUE) {
return(
list(
model_fit = model_fit,
param_est = param_est
)
)
} else {
return(model_fit)
}
}
expect_error(cv_ssnet(model = "ss",
x = matrix(rnorm(10*10), nrow = 10, ncol = 10),
y = rnorm(10),
foldid = list(f1 = sample(1:3, 10, T),
f2 = sample(1:3, 10, T))),
"foldid must be a numeric vector, matrix, or data frame."
)
expect_error(cv_ssnet(model = "ss",
x = matrix(rnorm(10*10), nrow = 10, ncol = 10),
y = rnorm(10),
foldid = data.frame(
f1 = sample(1:3, 10, T),
f2 = sample(1:4, 10, T))),
"Each column of foldid must have the same number of unique folds.")
#'
#' cv_ssnet(
#'   model = "ss", family = "multinomial",
#'   x = rbind(xtr, xte), y = c(ymtr, ymte),
#'   s0 = c(0.01, 0.05, 0.10), s1 = c(1, 2.5),
#'   nfolds = 3, ncv = 2, classify = FALSE,
#'   output_param_est = TRUE
#' )
#'
#' @export
cv_ssnet <- function(
model, alpha = c(0.5, 1),
s0 = seq(0.01, 0.1, 0.01), s1 = c(1, 2.5),
classify = FALSE, classify.rule = 0.5,
nfolds = 10, ncv = 1, foldid = NULL, fold.seed = NULL,
x, y, family, offset = NULL, epsilon = 1e-04,
maxit = 50, init = NULL, group = NULL,
Warning = FALSE, verbose = FALSE, opt.algorithm = "LBFGS",
iar.data = NULL, iar.prior = FALSE,
p.bound = c(0.01, 0.99), tau.prior = "none",
stan_manual = NULL, lambda.criteria = "lambda.min",
output_param_est = FALSE
)
{
# reproducibility
if (is.null(fold.seed) == FALSE) {
set.seed(fold.seed)
}
# for storing model fitness output
model_fit <- NULL
# for storing parameter estimates
if (output_param_est == TRUE) {
param_est <- NULL
}
# ensure foldid is valid or build foldid from scratch
if (is.null(foldid) == FALSE) {
if (
is.numeric(foldid) == FALSE &
is.matrix(foldid) == FALSE &
is.data.frame(foldid) == FALSE) {
stop("foldid must be a numeric vector, matrix, or data frame.")
#stop("foldid must be NULL or a (numeric) vector, matrix, or data frame.")
}
if (is.vector(foldid) == TRUE) {
ncv <- 1
nfolds <- length(unique(foldid))
foldid <- matrix(foldid, ncol = 1)
} else {
ncv <- ncol(foldid)
nfolds.b <- c()
for (nf in 1:ncv) {
nfolds.b[nf] <- length(unique(foldid[ , nf]))
}
if (any(nfolds.b != nfolds.b[1])) {
stop("Each column of foldid must have the same number of unique folds.")
} else {
nfolds <- nfolds.b[1]
}
}
} else {
foldid <- matrix(
sample(1:nfolds, size = nrow(x) * ncv, replace = TRUE),
ncol = ncv,
nrow = nrow(x)
)
}
# begin cv procedure
for (i in 1:ncv) {
for (j in 1:nfolds) {
# divide data into:
# training set (all but fold j)
xtr.ij <- x[foldid[ , i] != j, ]
ytr.ij <- y[foldid[ , i] != j]
# test set (fold j)
xte.ij <- x[foldid[ , i] == j, ]
yte.ij <- y[foldid[ , i] == j]
for (a in 1:length(alpha)) {
for (s0b in 1:length(s0)) {
for (s1b in 1:length(s1)) {
mod.ijas <- validate_ssnet(
model = model, family = family,
alpha = alpha[a], s0 = s0[s0b], s1 = s1[s1b],
x.train = xtr.ij, y.train = ytr.ij,
x.test = xte.ij, y.test = yte.ij,
classify = classify, classify.rule = classify.rule,
type.multinomial = type.multinomial,
offset = offset, epsilon = epsilon,
maxit = maxit, init = init, group = group,
Warning = Warning, verbose = verbose,
opt.algorithm = opt.algorithm,
iar.data = iar.data, iar.prior = iar.prior,
p.bound = p.bound, tau.prior = tau.prior,
stan_manual = stan_manual, lambda.criteria = lambda.criteria,
output_param_est = output_param_est
)
if (output_param_est == FALSE) {
mod.fit.ijas <- cbind(
model = model,
ncv.id = i,
fold.id = j,
alpha = alpha[a],
s0 = s0[s0b],
s1 = s1[s1b],
mod.ijas
)
} else {
mod.fit.ijas <- cbind(
model = model,
ncv.id = i,
fold.id = j,
alpha = alpha[a],
s0 = s0[s0b],
s1 = s1[s1b],
mod.ijas$model_fitness
)
param.est.ijas <- cbind(
model = model,
ncv.id = i,
fold.id = j,
alpha = alpha[a],
s0 = s0[s0b],
s1 = s1[s1b],
mod.ijas$param_est
)
param_est <- dplyr::bind_rows(
param_est,
param.est.ijas
)
}
model_fit <- dplyr::bind_rows(
model_fit,
mod.fit.ijas
)
}
}
}
}
}
if (output_param_est == TRUE) {
return(
list(
model_fit = model_fit,
param_est = param_est
)
)
} else {
return(model_fit)
}
}
expect_error(cv_ssnet(model = "ss",
x = matrix(rnorm(10*10), nrow = 10, ncol = 10),
y = rnorm(10),
foldid = data.frame(
f1 = sample(1:3, 10, T),
f2 = sample(1:4, 10, T))),
"Each column of foldid must have the same number of unique folds.")
library(ssnet)
?installed.packages
?De
BhGLM::De
?BhGLM::De
?ssnet
?BhGLM::bglm
BhGLM::De
?cv_ssnet
